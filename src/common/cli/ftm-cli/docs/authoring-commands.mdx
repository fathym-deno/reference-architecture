# Authoring CLI Commands

In the Fathym CLI framework, commands are modular, composable, and testable units of logic. You can define them fluently or as classes, each with a shared lifecycle and access to services via the IoC container. This guide shows you how to build CLI commands the right way‚Äîfrom quick scripts to deeply integrated toolchains.

## Fluent API (Recommended)

The preferred approach is the fluent `Command()` builder, which provides a clean, typesafe DSL for defining logic, parameters, and lifecycle hooks. Every command must include typed argument and flag schemas, and must specify a `CommandParams` class for runtime access.

Here‚Äôs a simple command to get started:

```ts
// commands/hello.ts
import { z } from '@fathym/common/third-party/zod';
import { Command, CommandParams } from '@fathym/common/cli';

const HelloArgsSchema = z.tuple([
  z.string().optional().describe('Name to greet'),
]);

const HelloFlagsSchema = z.object({
  loud: z.boolean().optional().describe('Shout the greeting'),
  'dry-run': z.boolean().optional().describe('Show the message without printing'),
});

class HelloParams extends CommandParams<
  z.infer<typeof HelloArgsSchema>,
  z.infer<typeof HelloFlagsSchema>
> {
  get Name() {
    return this.Arg(0) ?? 'world';
  }

  get Loud() {
    return this.Flag('loud') ?? false;
  }

  get DryRun() {
    return this.Flag('dry-run') ?? false;
  }
}

export default Command('hello', 'Prints a friendly greeting.')
  .Args(HelloArgsSchema)
  .Flags(HelloFlagsSchema)
  .Params(HelloParams)
  .Run(({ Params, Log }) => {
    const message = Params.Loud
      ? `HELLO, ${Params.Name.toUpperCase()}!`
      : `Hello, ${Params.Name}.`;

    if (Params.DryRun) {
      Log.Info(`üõë Dry run: "${message}" would have been printed.`);
    } else {
      Log.Info(message);
    }
  });
```

‚úÖ You only need to export the command as `default`. No need to export `Args`, `Flags`, or `Params` unless reused elsewhere.

## Subcommands

Use `.Commands({})` to define nested subcommands under a shared namespace.

```ts
import { Command } from '@fathym/common/cli';
import Promote from './promote.ts';
import Diff from './diff.ts';

export default Command('schema', 'Schema-related commands')
  .Commands({
    promote: Promote,
    diff: Diff,
  });
```

üìÅ The parent does not require `.Run()`; it delegates to the appropriate subcommand at runtime. Subcommands should be authored as complete command modules and exported as the default from their respective files.

## Class-Based Commands

For full control and deeper customization, extend the `CommandRuntime` base class.

```ts
import { CommandRuntime, CommandContext } from '@fathym/common/cli';

export class HelloCommand extends CommandRuntime {
  override async Run(ctx: CommandContext) {
    const name = ctx.Params.Arg(0) ?? 'world';
    ctx.Log.Info(`Hello, ${name}!`);
  }
}
```

To define and register it:

```ts
import { defineCommandModule } from '@fathym/common/cli';

export default defineCommandModule({
  ArgsSchema: z.tuple([z.string().optional()]),
  FlagsSchema: z.object({ loud: z.boolean().optional() }),
  Params: HelloParams,
  Command: HelloCommand,
});
```

Used for advanced generators, devtools, or commands with dynamic metadata.

---

### üîÑ Fluent API Under the Hood

Every fluent `Command()` definition compiles into a class-based equivalent at runtime. Specifically:

* Your `.Run()` becomes a class method `Run(ctx)`.
* Lifecycle hooks like `.Init()` and `.Cleanup()` map to their method counterparts.
* `.Args()`, `.Flags()`, and `.Params()` are preserved as static metadata.

This means:

* Fluent commands are fully compatible with the class runtime.
* You can promote any fluent command to a class manually for advanced use cases.
* Intent tests, lifecycle hooks, and service resolution work identically in both forms.

üß† Think of the fluent API as ergonomic syntax sugar ‚Äî underneath, everything flows through `CommandRuntime`.

## Lifecycle Hooks

Both APIs support the same lifecycle methods:

| Hook        | Purpose                                       |
| ----------- | --------------------------------------------- |
| `Init()`    | Prepare command before execution              |
| `Run()`     | Main logic body                               |
| `Cleanup()` | Finalization (even after failure)             |
| `DryRun()`  | Simulated execution for `--dry-run` scenarios |

All hooks receive the `CommandContext` and access to the shared IoC container.

üß† Use these for setup, teardown, config resolution, or simulating effects.

## Arguments, Flags, and Params

Every command requires a definition of its input contract via `.Args()`, `.Flags()`, and `.Params()`.

```ts
const ArgsSchema = z.tuple([
  z.string().describe('The target name'),
]);

const FlagsSchema = z.object({
  debug: z.boolean().optional().describe('Enable debug mode'),
});

class MyParams extends CommandParams<
  z.infer<typeof ArgsSchema>,
  z.infer<typeof FlagsSchema>
> {
  get Target() {
    return this.Arg(0);
  }

  get Debug() {
    return this.Flag('debug') ?? false;
  }
}
```

üì¶ `Args` and `Flags` define the raw shape, while `Params` creates expressive accessors and derived behavior.

‚úÖ Always attach all three to your command. This ensures:

* Type inference in CLI help and tests
* Input validation and normalization
* Cleaner command body via `Params` methods

## Testing Commands with Intents

You can write tests using either the `CommandIntent()` or the full `CommandIntents()` suite for grouped behaviors. These helpers simulate CLI input and validate output with full lifecycle accuracy.

### ‚úÖ Individual Intents

```ts
import { CommandIntent } from '@fathym/common/cli';
import WaveCommand from '../commands/wave.ts';

const origin = import.meta.resolve('../.cli.json');

CommandIntent('waves at default friend', WaveCommand, origin)
  .Args([undefined])
  .Flags({})
  .ExpectLogs('üëã Waving at friend')
  .ExpectExit(0)
  .Run();

CommandIntent('waves at a specific person', WaveCommand, origin)
  .Args(['me'])
  .Flags({})
  .ExpectLogs('üëã Waving at me')
  .ExpectExit(0)
  .Run();
```

### üß™ Test Suites with `CommandIntents()`

```ts
import { CommandIntents } from '@fathym/common/cli';
import HelloCommand from '../commands/hello.ts';
import initFn from '../.cli.init.ts';

const cmd = HelloCommand.Build();
const origin = import.meta.resolve('../.cli.json');

CommandIntents('Hello Command Suite', cmd, origin)
  .WithInit(initFn)
  .Intent('Greet default world', (int) =>
    int
      .Args([undefined])
      .Flags({})
      .ExpectLogs('üëã Hello, world')
      .ExpectExit(0),
  )
  .Intent('Greet a specific name', (int) =>
    int
      .Args(['me'])
      .Flags({})
      .ExpectLogs('üëã Hello, me')
      .ExpectExit(0),
  )
  .Intent('Greet loudly', (int) =>
    int
      .Args(['team'])
      .Flags({ loud: true })
      .ExpectLogs('üëã HELLO, TEAM')
      .ExpectExit(0),
  )
  .Intent('Dry run greeting', (int) =>
    int
      .Args(['sandbox'])
      .Flags({ 'dry-run': true })
      .ExpectLogs('üõë Dry run: "Hello, sandbox!" would have been printed.')
      .ExpectExit(0),
  )
  .Intent('Dry run loud greeting', (int) =>
    int
      .Args(['everyone'])
      .Flags({ 'dry-run': true, loud: true })
      .ExpectLogs('üõë Dry run: "HELLO, EVERYONE!" would have been printed.')
      .ExpectExit(0),
  )
  .Run();
```

üß† Each intent validates logs, parameters, and exit codes, and ensures your command behaves predictably with full lifecycle simulation.

```ts
import Hello from '../commands/hello.ts';

export default new CommandIntent(Hello, 'says hello', import.meta.url)
  .Args(['world'])
  .Flags({ loud: true })
  .ExpectLogs('HELLO, WORLD!')
  .Run();
```

üß™ Intents validate logs, parameters, and behavior with CI-ready assertions.

## Tips & Best Practices

‚úÖ Use fluent API for clarity and speed
üìÅ Isolate each command in its own file
üéØ Wrap arg/flag logic in a `Params` class
üß™ Add a `*.intent.ts` test per command
ü™Ñ Register shared services in `.cli.init.ts`
üì¶ Use `.Commands({})` for clean nesting ‚Äî avoid `if (cmd === ...)`

## Related Topics

* [Command Lifecycle](./command-lifecycle.md)
* [Command Intents (Testing)](./command-intents.md)
* [Templates & Scaffolding](./templates.md)
* [CLI Configuration](./configuration.md)
* [Compiling CLI Binaries](./compilation.md)
