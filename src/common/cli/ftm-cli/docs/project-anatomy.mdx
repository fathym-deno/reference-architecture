# CLI Project Anatomy

You’ve already initialized and run your CLI. Now let’s break it down — file by file, folder by folder. This isn’t boilerplate. Each piece is part of a statically compiled, testable, declarative runtime. Here’s what powers it.

## Initial Scaffold

After initializing a CLI project, your file structure might look like this:

```txt
my-cli/
├── .cli.json          # Primary config (project token, paths, etc.)
├── .cli.init.ts       # Optional init hook (IoC, services, preboot logic)
├── deno.jsonc         # Deno tooling config (optional)
├── commands/          # Authored command logic
├── intents/           # Intent-driven CLI behavior tests
├── templates/         # Optional scaffolding templates
├── .gitignore         # Preconfigured for builds
└── .vscode/           # Dev hints (optional)
```

> 🧠 This structure reflects the runtime you just compiled — the CLI is declarative, embedded, and injectable by design.

| Folder / File | Purpose                 | Created By     | Editable? |
| ------------- | ----------------------- | -------------- | --------- |
| `.cli.json`   | CLI config + metadata   | `init`         | ✅         |
| `commands/`   | CLI command logic       | `init`         | ✅         |
| `intents/`    | CLI command tests       | `init`         | ✅         |
| `templates/`  | CLI scaffolding         | optional       | ✅         |
| `.build/`     | Embedded CLI output     | `ftm build`    | ❌         |
| `.dist/`      | Native binary output    | `ftm compile`  | ❌         |
| `.temp/`      | Temporary runtime cache | dev/test flows | ❌         |

### `.cli.json`

Defines the identity and structure of your CLI:

* **Tokens**: Entrypoint names
* **Commands**: Folder where your logic lives
* **Templates**: Scaffolding sources for generators

This config is parsed by `CLIDFSContextManager`, used during both `deno run` and native binary execution.

### `.cli.init.ts`

Optional bootstrap hook to register services into the IoC container. Runs before any command is dispatched and can be used to:

* Inject shared services
* Set logging/debug modes
* Register dynamic runtime behaviors

### `commands/`

This folder is the main surface for authored CLI logic. Each file exports a command object and optional parameter types:

```ts
export const Command = ...
export const Params = ...
```

You can use either the fluent `Command(...)` builder or subclass `CommandRuntime` with `Init`, `Run`, and `Cleanup` hooks.

### `intents/`

Declarative tests for CLI behavior using `CommandIntentBuilder`. These:

* Simulate real invocation (`Args`, `Flags`, etc.)
* Assert logs, exit codes, and behavior
* Are runnable via `deno test` or `ftm test`

### `templates/`

An optional folder containing named scaffolding templates. Each top-level folder inside `templates/` is treated as the name of a template and can include any file or folder structure that should be copied or transformed when a generator is invoked.

Templates are authored using the Handlebars syntax. During generation, `ftm` will resolve placeholders and substitute values into the generated files.

Used when `ftm generate` or similar commands are wired into your CLI logic.

### `deno.jsonc`

Optional local config for dev tooling. You can customize:

* Import maps
* Lint/format rules
* Tasks and scripts

This file is not used in the CLI runtime.

## Build & Compile Output

During build and compile phases, the following directories are created:

```txt
my-cli/
├── .build/                      # Generated by `ftm build`
│   ├── cli.ts                   # Entry module (compiled CLI entrypoint)
│   ├── embedded-templates.json  # Templates embedded as JSON
│   └── embedded-command-entries.json
├── .dist/                       # Generated by `ftm compile`
│   └── ftm-cli                  # Native binary output
├── .temp/                       # Ephemeral runtime staging (optional)
```

### `.build/`

This is the staging area for CLI compilation. It includes:

* `cli.ts`: The generated Deno entrypoint
* `embedded-*.json`: Static manifests of commands and templates

Used by both runtime execution and `deno compile`.

### `.dist/`

Final compiled output of `ftm compile`. This folder contains:

* `ftm-cli`: A native binary (name taken from `.cli.json → Tokens[0]`)
* Portable, Deno-free execution

### `.temp/`

This ephemeral directory supports internal runtime workflows:

* Temporary runner modules
* Sandboxed command environments
* Used in test or dev execution

Not committed or required in most cases.

## Runtime Flow

The CLI runtime is fully declarative, from config to command execution.

```txt
ftm init     → .cli.json, commands/, templates/
     ↓
ftm build    → .build/ (embedded CLI runtime)
     ↓
ftm compile  → .dist/ (binary CLI)
     ↓
ftm test     → intents/
```

<figure class="my-16 flex flex-col items-center text-center max-w-xl w-full">
  <img
    src="/assets/docs/cli-runtime-flow.png"
    alt="Diagram showing the flow from .cli.json through commands, build, and compile stages into a final executable."
    class="rounded-2xl shadow-2xl ring-1 ring-white/10 w-full"
  />
  <figcaption class="mt-4 text-sm text-gray-400 tracking-wide uppercase">
    CLI project lifecycle: From authored config to native execution.
  </figcaption>
</figure>

Key highlights:

* ✅ **Config-driven**: The `.cli.json` defines your CLI shape and structure.
* 🔧 **Buildable**: Convert authored logic into a static entrypoint via `ftm build`.
* 🧠 **Compilable**: Package the entire system as a native binary with `ftm compile`.
* ⌛ **Extendable**: `.cli.init.ts` can inject runtime behavior without touching commands.

## Testing with Intents

Intent-driven tests validate CLI behavior through lifecycle simulation:

* Covers full flow: `Init → Run → Cleanup`
* Validates logs, output, and side effects
* Written like real invocations

Example:

```ts
CommandIntent('waves at default friend', WaveCommand, import.meta.url)
  .Args([undefined])
  .Flags({})
  .ExpectLogs('👋 Waving at friend')
  .ExpectExit(0)
  .Run();
```

Run tests via:

```bash
deno test -A intents/
```

Or, use the forthcoming:

```bash
ftm test
```

## Related Topics

* [Authoring Commands](./authoring-commands.md)
* [Templates & Scaffolding](./templates.md)
* [Testing with Command Intents](./command-intents.md)
* [Compiling Your CLI](./compilation.md)
* [CLI Execution Lifecycle](./command-lifecycle.md)
